# شبیه‌ساز سلسله‌مراتب حافظه (Memory Hierarchy Simulator)

## معرفی پروژه

این پروژه یک شبیه‌ساز جامع و تعاملی برای سلسله‌مراتب حافظه کامپیوتر است که به منظور درک بهتر مفاهیم معماری کامپیوتر، به‌ویژه سیستم‌های کش و سیاست‌های جایگزینی طراحی شده است. این برنامه با استفاده از فریمورک Avalonia UI و زبان برنامه‌نویسی C# پیاده‌سازی شده و قابلیت شبیه‌سازی سطوح مختلف حافظه (L1، L2، L3، RAM و حافظه جانبی) را دارا می‌باشد.

**پروژه درس معماری و سازمان کامپیوتر - دانشگاه صنعتی اصفهان**

## ویژگی‌های کلیدی

- شبیه‌سازی سه سطح کش (L1، L2، L3) با پیکربندی‌های قابل تنظیم
- پشتیبانی از 8 سیاست جایگزینی مختلف
- تولید 6 الگوی دسترسی متنوع به حافظه
- نمایش نتایج به صورت نمودار و جدول تعاملی
- قابلیت مقایسه عملکرد تمام سیاست‌های جایگزینی
- محاسبه دقیق Hit Rate، Miss Rate و زمان دسترسی
- رابط کاربری گرافیکی و کاربرپسند
- پشتیبانی کامل از Windows، macOS و Linux

---

## معماری شبیه‌ساز

### سطوح سلسله‌مراتب حافظه

#### کش سطح اول (L1 Cache)
- **سریع‌ترین** و **کوچک‌ترین** سطح کش
- مستقیماً به پردازنده متصل است
- زمان دسترسی پیش‌فرض: 1 سیکل
- اندازه پیش‌فرض: 32 KB
- تعداد خطوط (Ways): 4

#### کش سطح دوم (L2 Cache)
- حجیم‌تر و کمی کندتر از L1
- میانجی بین L1 و L3
- زمان دسترسی پیش‌فرض: 10 سیکل
- اندازه پیش‌فرض: 256 KB
- تعداد خطوط: 8

#### کش سطح سوم (L3 Cache)
- بزرگ‌ترین سطح کش
- معمولاً بین چندین هسته به اشتراک گذاشته می‌شود
- زمان دسترسی پیش‌فرض: 30 سیکل
- اندازه پیش‌فرض: 8 MB
- تعداد خطوط: 16

#### حافظه اصلی (RAM)
- ذخیره‌سازی موقت داده‌ها و دستورات
- زمان دسترسی پیش‌فرض: 100 سیکل

#### حافظه جانبی (Secondary Storage)
- کندترین اما با بیشترین ظرفیت
- زمان دسترسی پیش‌فرض: 10,000 سیکل

---

## سیاست‌های جایگزینی کش

این شبیه‌ساز از **8 سیاست جایگزینی** مختلف پشتیبانی می‌کند:

### 1. LRU (Least Recently Used)
**توضیح**: بلوکی که مدت طولانی‌تری استفاده نشده، جایگزین می‌شود.

**کاربرد**:
- برای برنامه‌هایی با Temporal Locality بالا
- رایج‌ترین سیاست در سیستم‌های واقعی
- عملکرد خوب در اکثر سناریوها

**مزایا**: نرخ Hit بالا در الگوهای معمول، پیش‌بینی رفتار خوب

**معایب**: نیاز به ذخیره‌سازی زمان آخرین دسترسی، پیچیدگی پیاده‌سازی متوسط

---

### 2. FIFO (First In, First Out)
**توضیح**: قدیمی‌ترین بلوک موجود در کش جایگزین می‌شود (به ترتیب ورود).

**کاربرد**:
- برنامه‌های با دسترسی خطی
- زمانی که داده‌های قدیمی احتمالاً دیگر استفاده نمی‌شوند

**مزایا**: پیاده‌سازی بسیار ساده، عادلانه و قابل پیش‌بینی

**معایب**: ممکن است بلوک‌های پرکاربرد را حذف کند، عملکرد ضعیف‌تر از LRU

---

### 3. Random
**توضیح**: بلوکی به صورت **تصادفی** برای جایگزینی انتخاب می‌شود.

**کاربرد**:
- زمانی که پیش‌بینی الگوی دسترسی غیرممکن است
- برنامه‌های با رفتار کاملاً تصادفی

**مزایا**: ساده‌ترین پیاده‌سازی، سربار محاسباتی صفر

**معایب**: عملکرد غیرقابل پیش‌بینی، معمولاً ضعیف‌تر از سیاست‌های هوشمندتر

---

### 4. LFU (Least Frequently Used)
**توضیح**: بلوکی که **کمترین تعداد دسترسی** را داشته، جایگزین می‌شود.

**کاربرد**:
- برنامه‌هایی که برخی داده‌ها بیشتر استفاده می‌شوند
- الگوهای دسترسی با فرکانس ثابت

**مزایا**: داده‌های پرکاربرد را نگه می‌دارد، عالی برای Hot Data

**معایب**: مشکل Pollution (بلوک‌های کهنه با فرکانس بالا)، نیاز به شمارنده برای هر بلوک

---

### 5. MRU (Most Recently Used)
**توضیح**: برعکس LRU - **آخرین بلوک استفاده شده** جایگزین می‌شود.

**کاربرد**:
- الگوهای دسترسی حلقه‌ای با دوره‌های طولانی
- دسترسی‌های Sequential بزرگ که مجدداً استفاده نمی‌شوند

**مزایا**: در برخی الگوهای خاص (مثل Scan) بهتر از LRU

**معایب**: در اکثر برنامه‌های واقعی عملکرد ضعیف، بر خلاف شهود

---

### 6. Round Robin (RR)
**توضیح**: بلوک‌ها به صورت **چرخشی** جایگزین می‌شوند.

**کاربرد**:
- زمانی که انصاف مهم است
- تست و مقایسه baseline

**مزایا**: پیاده‌سازی بسیار ساده، توزیع یکنواخت

**معایب**: هیچ اطلاعاتی از الگوی دسترسی استفاده نمی‌کند

---

### 7. Second Chance
**توضیح**: نسخه بهبودیافته FIFO با یک **بیت مرجع** (Reference Bit).

**نحوه کار**:
1. هر بلوک یک بیت Reference دارد
2. وقتی به بلوک دسترسی می‌شود، بیت آن 1 می‌شود
3. در زمان جایگزینی، اگر بیت = 1، بیت را صفر کرده و به بلوک بعدی می‌رود
4. اولین بلوک با بیت = 0 جایگزین می‌شود

**کاربرد**: ترکیب سادگی FIFO با هوشمندی LRU، سیستم‌عامل‌ها (Page Replacement)

**مزایا**: بهتر از FIFO خالص، شانس دوم برای بلوک‌های اخیراً استفاده شده

---

### 8. LFRU (Least Frequently Recently Used)
**توضیح**: **ترکیب LFU و LRU** - بلوک با کمترین فرکانس و قدیمی‌ترین زمان دسترسی جایگزین می‌شود.

**نحوه کار**:
1. اولویت با فرکانس استفاده (کمترین بهتر)
2. در صورت برابری فرکانس، زمان آخرین دسترسی (قدیمی‌تر بهتر)

**کاربرد**: الگوهای پیچیده با هم Temporal و هم Frequency locality

**مزایا**: ترکیب مزایای LFU و LRU، حل مشکل Pollution در LFU

**معایب**: پیچیده‌ترین پیاده‌سازی، سربار حافظه و محاسباتی بیشتر

---

## الگوهای دسترسی به حافظه

### Sequential (متوالی)
دسترسی به آدرس‌های پشت سر هم: `0, 1, 2, 3, 4, 5, ...`

**کاربرد**: خواندن آرایه‌ها، پردازش خطی داده

### Random (تصادفی)
دسترسی کاملاً تصادفی به آدرس‌ها: `42, 7, 193, 54, 8, ...`

**کاربرد**: جستجوی پراکنده، دسترسی‌های غیرمنظم

### Locality (محلی)
دسترسی به محدوده‌های کوچک با احتمال بالا: `5, 7, 6, 5, 8, 6, ...`

**کاربرد**: برنامه‌های واقعی با Temporal/Spatial Locality

### Stride (گام‌دار)
دسترسی با فاصله ثابت: `0, 4, 8, 12, 16, ...`

**کاربرد**: دسترسی به ماتریس‌ها، پردازش هر n-امین عنصر

### Loop (حلقه‌ای)
تکرار دسترسی به مجموعه کوچکی از آدرس‌ها: `0, 1, 2, 3, 0, 1, 2, 3, ...`

**کاربرد**: حلقه‌های کوچک، Working Set محدود

### Mixed (ترکیبی)
ترکیبی از الگوهای بالا

**کاربرد**: شبیه‌سازی واقع‌گرایانه برنامه‌های واقعی

---

## نحوه استفاده

### پیش‌نیازها

- **.NET 8.0 SDK** یا بالاتر
- دانلود از: https://dotnet.microsoft.com/download/dotnet/8.0

### نصب و اجرا

#### روش 1: اجرای مستقیم
```bash
cd src
dotnet restore
dotnet run
```

#### روش 2: Build و اجرا
```bash
cd src
dotnet build
dotnet run --no-build
```

#### روش 3: Publish
```bash
cd src
dotnet publish -c Release -r win-x64 --self-contained
```

---

## راهنمای رابط کاربری

### پنل پیکربندی (سمت چپ)

**تنظیمات کش L1/L2/L3**:
- حجم کش (KB)
- اندازه بلوک (Byte)
- Associativity (Ways)
- Latency (Cycles)

**تنظیمات شبیه‌سازی**:
- تعداد دسترسی
- الگوی دسترسی (6 گزینه)
- سیاست جایگزینی (8 گزینه)
- نسبت خواندن (Read Ratio %)
- محدوده آدرس (Max Address)

### دکمه‌های کنترل

- **Run Simulation**: اجرای شبیه‌سازی با تنظیمات فعلی
- **Compare All Policies**: مقایسه تمام 8 سیاست
- **Reset**: بازگشت به تنظیمات پیش‌فرض

### نمایش نتایج

**کارت‌های آماری**:
- Total Accesses
- Hit Rate (%)
- Miss Rate (%)
- Average Latency (Cycles)

**نمودار عملکرد**: نمودار میله‌ای Hit/Miss در هر سطح (L1, L2, L3, RAM, Disk)

**جدول جزئیات**: آدرس، نوع عملیات (Read/Write)، نتیجه (Hit/Miss)، سطح Hit، Latency

### تب مقایسه

- نمودار مقایسه Hit Rate تمام سیاست‌ها
- لاگ‌های اجرا
- توضیحات سیاست انتخاب‌شده

---

## سناریوهای آزمایش پیشنهادی

### آزمایش 1: مقایسه LRU vs FIFO
- الگوی دسترسی: Sequential
- نتیجه مورد انتظار: LRU بهتر از FIFO

### آزمایش 2: تأثیر اندازه کش
- کش L1: ابتدا 16KB، سپس 64KB، سپس 256KB
- نتیجه مورد انتظار: با افزایش حجم، Hit Rate افزایش یابد

### آزمایش 3: LFU vs LFRU
- الگوی دسترسی: Mixed
- نتیجه مورد انتظار: LFRU بهتر در الگوهای پیچیده

### آزمایش 4: تأثیر Associativity
- L1 Associativity: 2-way، 4-way، 8-way
- نتیجه مورد انتظار: با افزایش Ways، Miss Rate کاهش یابد

---

## ساختار پروژه

```
src/
├── Models/Models.cs                # مدل‌های داده
├── Services/
│   ├── ReplacementStrategies.cs    # پیاده‌سازی 8 سیاست
│   └── Services.cs                 # موتور شبیه‌ساز
├── ViewModels/MainViewModel.cs     # منطق Presentation
├── Views/
│   ├── MainWindow.axaml            # طراحی UI
│   └── MainWindow.axaml.cs
├── App.axaml                       # تنظیمات UI
├── App.axaml.cs
└── Program.cs                      # نقطه ورود
```

---

## جزئیات فنی

- **الگوی طراحی**: MVVM
- **UI Framework**: Avalonia UI 11.x
- **Charting**: LiveCharts 2.0
- **زبان**: C# 12
- **Framework**: .NET 8.0

---

## نکات عملکردی

### انتخاب اندازه بلوک
- بلوک‌های بزرگ‌تر (64-128 بایت): بهتر برای Spatial Locality
- بلوک‌های کوچک‌تر (16-32 بایت): بهتر برای داده‌های پراکنده

### تعداد Ways
- Direct-Mapped (1-way): سریع اما Conflict Miss بالا
- Fully-Associative: Miss کم اما پیچیده
- Set-Associative (4-8 way): بهترین تعادل

### انتخاب سیاست
- الگوی Sequential: FIFO یا LRU
- الگوی Random: همه سیاست‌ها تقریباً مشابه
- الگوی Locality: LRU یا LFRU
- الگوی Loop: بستگی به اندازه Loop دارد

---

## توسعه‌های آینده

- پشتیبانی از معماری Multi-core
- شبیه‌سازی Coherence Protocols (MESI, MOESI)
- افزودن Write-back و Write-allocate
- Import کردن Trace های واقعی
- Export نتایج به CSV/JSON

---

## مراجع

- Computer Organization and Design - Patterson & Hennessy
- Computer Architecture: A Quantitative Approach - Hennessy & Patterson

---

**پروژه درس معماری و سازمان کامپیوتر**
**دانشگاه صنعتی اصفهان - 1403**
